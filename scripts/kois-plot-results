#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import kplr
import h5py
import logging
import triangle
import numpy as np
import cPickle as pickle
import matplotlib.pyplot as pl
from matplotlib.ticker import MaxNLocator

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Build a KOI model")
    parser.add_argument("basedir", help="The path to the model directory")
    parser.add_argument("-b", "--burnin", default=0, type=int,
                        help="The number of steps to discard")
    parser.add_argument("-t", "--thin", default=1, type=int,
                        help="The number of steps to skip when thinning")
    parser.add_argument("-o", "--outdir", default=None,
                        help="The directory where the output files will be "
                        "written")
    parser.add_argument("--triangle", action="store_true",
                        help="Make the triangle plot")
    args = parser.parse_args()

    # logging.basicConfig(level=logging.INFO)

    # Set up the output directory.
    outdir = args.outdir
    if outdir is None:
        outdir = args.basedir
    try:
        os.makedirs(outdir)
    except os.error:
        logging.info("Output directory '{0}' exists".format(outdir))

    # Load the pickled model.
    logging.info("Loading the precomputed model.")
    model = pickle.load(open(os.path.join(args.basedir, "model.pkl")))
    # columns = [c.strip()
    #            for c in open(os.path.join(args.basedir, "mcmc.txt"))
    #            .readline()[1:].split()]
    n = len(model.periods)
    columns = (["g1", "g2"] +
               ["p{0}".format(i+1) for i in range(n)] +
               ["t{0}".format(i+1) for i in range(n)] +
               ["d{0}".format(i+1) for i in range(n)] +
               ["r{0}".format(i+1) for i in range(n)] +
               ["b{0}".format(i+1) for i in range(n)])

    # Load the results.
    print("Loading samples")
    # samples = np.loadtxt(os.path.join(args.basedir, "mcmc.txt"))
    # niter, nwalkers = int(samples[-1, 0])+1, int(samples[-1, 1])+1
    # chain = samples.reshape((niter, nwalkers, -1))
    # chain = chain[:, :, 2:]
    with h5py.File(os.path.join(args.basedir, "mcmc.h5"), "r") as f:
        i = f.attrs["iteration"]
        chain = f["samples"][:, :i, :]
        lnprob = f["lnprob"][:, :i]
    nwalkers, niter, ndim = chain.shape

    # Plot the time series.
    print("Making time series plots")
    ndim = chain.shape[-1]
    factor = 1.5
    bdim = 0.5 * factor   # size of bottom margin
    tdim = 0.05 * factor  # size of top margin
    fig, axes = pl.subplots(ndim, 1, figsize=(8, factor*ndim), sharex=True)
    fig.subplots_adjust(left=0.17, bottom=bdim/(factor*ndim), right=0.9,
                        top=1-tdim/(factor*ndim), wspace=0.05, hspace=0.05)
    for i, (ax, c) in enumerate(zip(axes, columns[2:])):
        ax.plot(chain[:, :, i], color="k", alpha=0.3)
        ax.annotate(c, xy=(1, 0), xytext=(-5, 5), xycoords="axes fraction",
                    textcoords="offset points", ha="right", va="bottom")
        ax.yaxis.set_major_locator(MaxNLocator(4))
        ax.axvline(args.burnin, color="#888888", alpha=0.5, lw=3)
        ax.set_xlim(0, niter)
    axes[-1].set_xlabel("steps")
    pl.savefig(os.path.join(outdir, "time.png"))

    assert 0

    # Find the MAP sample.
    ind = np.argmax(samples[:, -1])
    model.vector = samples[ind, 2:-1]
    map_periods = np.array(model.periods)
    map_epochs = np.array(model.epochs)
    map_durations = np.array(model.durations)

    # Plotting predictions.
    print("Plotting predictions")
    nplanets = len(model.periods)
    figs, axes_list = zip(*[pl.subplots(2, 1, figsize=(6, 6), sharex=True)
                            for i in range(nplanets)])
    [f.subplots_adjust(left=0.17, bottom=0.1, right=0.9, top=0.9,
                       wspace=0.05, hspace=0.05) for f in figs]
    thinned_chain = samples[nwalkers*args.burnin::args.thin, 2:-1]
    for j, ind in enumerate(np.random.randint(len(thinned_chain), size=100)):
        model.vector = thinned_chain[ind]

        for i, (P, t0, dur, fig, axes) in enumerate(zip(map_periods,
                                                        map_epochs,
                                                        map_durations, figs,
                                                        axes_list)):
            if j == 0:
                # Plot the folded datasets.
                hp = 0.5 * P
                for d in model.datasets:
                    ax = axes[0]
                    if d.texp < 0.01:
                        ax = axes[1]
                    ax.plot((d.time-t0+hp) % P - hp, d.flux, ".k", alpha=0.3,
                            ms=3)

            # Plot the models.
            t = np.linspace(-4*dur, 4*dur, 1000)
            lc = kplr.EXPOSURE_TIMES[1]/86400.0
            axes[0].plot(t, model.get_light_curve(t+t0, K=5, texp=lc), "r",
                         alpha=0.1)
            sc = kplr.EXPOSURE_TIMES[0]/86400.0
            axes[1].plot(t, model.get_light_curve(t+t0, K=3, texp=sc), "r",
                         alpha=0.1)

    for i, (P, dur, fig, axes) in enumerate(zip(map_periods,
                                                model.initial_durations, figs,
                                                axes_list)):
        # Set the y-axis limits.
        for ax in axes:
            ylim = min(ax.get_ylim()[0] - 1, -1e-3)
            ax.set_ylim(1+1.2*ylim, 1-0.6*ylim)

        # Labels.
        axes[0].set_xlim(-4*dur, 4*dur)
        axes[0].set_title("{0:02d}, period = {1} days"
                          .format(i+1, P))
        axes[1].set_xlabel("time since transit")

        fig.savefig(os.path.join(args.basedir, "final-lc-{0:02d}.png"
                                 .format(i+1)))

    # Plot the triangle plot.
    if not args.triangle:
        sys.exit(0)

    print("Making triangle plot")
    cs = np.concatenate((samples[nwalkers*args.burnin::args.thin, 2:],
                         samples[nwalkers*args.burnin::args.thin, :1]), axis=1)
    fig = triangle.corner(cs, labels=columns[2:] + ["iter"],
                          quantiles=[0.16, 0.5, 0.84])
    fig.savefig(os.path.join(outdir, "triangle.png"))
